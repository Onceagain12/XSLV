/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. src/dongfang/xsltools/xpath2/XPathParser.jj.jj */
/*@egen*/options {
  LOOKAHEAD = 3;
  FORCE_LA_CHECK = true;                
  STATIC = false;                                                     
}

PARSER_BEGIN(XPathParser)
package dongfang.xsltools.xpath2;

import java.io.Reader;
import java.io.StringReader;
import dongfang.xsltools.model.NamespaceExpander;
import dongfang.xsltools.model.ElementNamespaceExpander;
import dongfang.xsltools.model.NullNamespaceExpander;
import org.dom4j.Element;
import dongfang.xsltools.exceptions.XSLToolsXPathParseException;

public class XPathParser/*@bgen(jjtree)*/implements XPathParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTXPathParserState jjtree = new JJTXPathParserState();

/*@egen*/

NamespaceExpander nsExpander = new NullNamespaceExpander();
String noPrefixBehavior = NamespaceExpander.BIND_PREFIXLESS_TO_NO_NAMESPACE;
static final boolean dump = false;

public static void main(String args[]) throws ParseException {

Reader stread = new StringReader(args[0]);
XPathParser parser = new XPathParser(stread);

long time = System.currentTimeMillis();
for (int i=0; i<1000; i++) {
stread = new StringReader(args[0]);
  parser.ReInit(stread);
  parser.XPath();
}

SimpleNode n = (SimpleNode)parser.jjtree.rootNode();
System.out.println(n);
n.dump("");
System.out.println("Time for 1000 shots: " + (System.currentTimeMillis() - time));
}

public void setNsExpander(NamespaceExpander expander) {
  this.nsExpander = expander;
}

public NamespaceExpander getNsExpander() {
  return nsExpander;
}

public XPathExpr getParseTree() {
  return (XPathExpr)jjtree.rootNode();
}

private static XPathParser p1 = new XPathParser(new StringReader(""));
private static XPathParser p2 = new XPathParser(new StringReader(""));
//private static XPathParser p3 = new XPathParser(new StringReader(""));
private static boolean escape = true;

static {
p1.setNsExpander(new NullNamespaceExpander());
p2.setNsExpander(new ElementNamespaceExpander(null));
}

// that silly parser just won't get some non-ISO-8859
// chars right. Just have to deal with them....
// convert to character entity refs....
private static String convertTroublemakers(String s) {
if (!escape)
return s;
  StringBuilder result = new StringBuilder();
  for (int i=0; i<s.length(); i++) {
    char c = s.charAt(i);
    if ((c >= 32 && c < 256) || c==9 || c==10 || c== 12 || c==13) {
      result.append(c);
    } else {
      result.append("#&x");
      result.append(Integer.toString(c, 16));
      result.append(";");
    }
  }
  return result.toString();
}

private static void reportError(String s, String message) {
  System.err.println("Failed to parse " + s + " : " + message);
  System.err.print('(');
  for (int i=0; i<s.length(); i++) {
    char c = s.charAt(i);
    if (i>0) 
      System.err.print(", ");
    System.err.print(Integer.toString(c));
  }
  System.err.println(')');
}

public static XPathExpr parse(String s) throws XSLToolsXPathParseException {
if (dump) System.err.println("Attempting to parse: " + s);
try {
p1.ReInit(new StringReader(convertTroublemakers(s)));
p1.XPath();
return p1.getParseTree();
} catch (Throwable ex) {
reportError(s, ex.getMessage());
throw new XSLToolsXPathParseException(ex);
}
}

public static XPathExpr parse(String s, NamespaceExpander exp) throws XSLToolsXPathParseException {
if (dump)System.err.println("Attempting to parse: " + s);
NamespaceExpander save = p1.getNsExpander();
p1.setNsExpander(exp);
try {
p1.ReInit(new StringReader(convertTroublemakers(s)));
p1.XPath();
p1.setNsExpander(save);
return p1.getParseTree();
} catch (Throwable ex) {
reportError(s, ex.getMessage());
throw new XSLToolsXPathParseException(ex);
}
}

public static XPathExpr parse(String s, Element expander,String noPrefixBehavior) throws XSLToolsXPathParseException {
if (dump)System.err.println("Attempting to parse: " + s);
try {
p2.ReInit(new StringReader(convertTroublemakers(s)));
p2.noPrefixBehavior = noPrefixBehavior;
ElementNamespaceExpander e = (ElementNamespaceExpander)p2.getNsExpander();
e.setElement(expander);
p2.XPath();
return p2.getParseTree();
} catch (Throwable ex) {
reportError(s, ex.getMessage());
throw new XSLToolsXPathParseException(ex);
}
}
}

PARSER_END(XPathParser)

SPECIAL_TOKEN :
{  " " | "\n" | "\t" | "\r" | "\f" }
SPECIAL_TOKEN :
{
  <XPATHCOMMENT: "(:" (~[])* ":)" >
}

TOKEN :
{
   < #DIGIT: ["0"-"9"] >
  | < STRINGLITERAL: (<QUOTE> (<QUOTE><QUOTE> | ~["\""] )* <QUOTE>) | (<APOS> (<APOS><APOS> | ~["'"])* <APOS>) >
  | < #EXPONENT: "e" | "E" >
  | < EQUAL: "=" > 
  | < NOTEQUAL: "!=" > 
  | < LESS: "<" > 
  | < LESSOREQUAL: "<=" > 
  | < GREATER: ">" > 
  | < GREATEROREQUAL: ">=" >
  | < DOLLAR: "$" >
  | < LPAREN: "(" >
  | < RPAREN: ")" >
  | < DOT: "." >
  | < COMMA: "," >
  | < COLON: ":" >
  | < STAR: "*" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < PIPE: "|" >
  | < LBRACKET: "[" >
  | < RBRACKET: "]" >
  | < QUESTION: "?" >
  | < QUOTE: "\"" >
  | < APOS: "'" >
  | < SLASH: "/" >
  | < AQUANR: "@" >
  | < SLASHSLASH: "//" >
  | < #COLONCOLON: "::" >
  | < LEFTLEFT: "<<" >
  | < RIGHTRIGHT: ">>" >
  | < DOTDOT: ".." >
  | < IN: "in" >
  | < IFLPAREN: "if" "(" >
  | < OR: "or" >
  | < OF: "of" >
  | < AS: "as" >
  | < EQ: "eq" >
  | < NE: "ne" >
  | < LT: "lt" >
  | < LE: "le" >
  | < GT: "gt" >
  | < GE: "ge" >
  | < IS: "is" >
  | < TO: "to" >
  | < FOR: "for" >
  | < DIV: "div" >
  | < MOD: "mod" >
  | < AND: "and" >
  | < THEN: "then" >
  | < ELSE: "else" >
  | < IDIV: "idiv" >
  | < SOME: "some" >
  | < CAST: "cast" >
  | < ITEMLPAREN: "item" "(" >
  | < NODELPAREN: "node" "(" >
  | < TEXTLPARENRPAREN: "text()" >
  | < EVERY: "every" >
  | < UNION: "union" >
  | < TREAT: "treat" >
  | < RETURN: "return" >
  | < EXCEPT: "except" >
  | < INSTANCE: "instance" >
  | < CASTABLE: "castable" >
  | < INTERSECT: "intersect" >
  | < EMPTY_SEQUENCELPAREN: "empty-sequence" "(" >
  | < DOCUMENT_NODELPAREN: "document-node" "(" >
  | < COMMENTLPAREN: "comment" "(">
  | < PROCESSING_INSTRUCTIONLPAREN: "processing-instruction" "(">
  | < ATTRIBUTELPAREN: "attribute" "(" >
  | < SCHEMA_ATTRIBUTELPAREN: "schema-attribute" "(" >
  | < ELEMENTLPAREN: "element" "(">
  | < SCHEMA_ELEMENTLPAREN: "schema-element" "(">
  | < SATISFIES: "satisfies" >
  | < CHILD_AXIS: "child::" >
  | < DESCENDANT_AXIS: "descendant::" >
  | < SELF_AXIS: "self::" >
  | < ATTRIBUTE_AXIS: "attribute::" >
  | < DESCENDANT_OR_SELF_AXIS: "descendant-or-self::" >
  | < FOLLOWING_SIBLING_AXIS: "following-sibling::" >
  | < FOLLOWING_AXIS: "following::" >
  | < NAMESPACE_AXIS: "namespace::" >
  | < PARENT_AXIS: "parent::" >
  | < ANCESTOR_AXIS: "ancestor::" >
  | < PRECEDING_SIBLING_AXIS: "preceding-sibling::" >
  | < PRECEDING_AXIS: "preceding::" >
  | < ANCESTOR_OR_SELF_AXIS: "ancestor-or-self::" >
  | < DOUBLE: ((<DOT> <DIGITS>) | (<DIGITS> (<DOT> (<DIGIT>)*)?)) <EXPONENT> ( <PLUS> | <MINUS> )? <DIGITS> >
  | < DECIMAL: (<DOT> <DIGITS>) | (<DIGITS> <DOT> (<DIGIT>)*) >
  | < DIGITS: (<DIGIT>)+ >
  | < ANYLOCALNAME: <NCNAME> <COLON> <STAR> >
  | < ANYNAMESPACENAME: <STAR> <COLON> <NCNAME> >
  | < QNAME: (<NCNAME> <COLON>)? <NCNAME> > 
  | < #NCNAME: (<LETTER> | "_") (<NCNAMECHAR>)* >
  | < #NCNAMECHAR: <LETTER> | <XMLDIGIT> | "." | "-" | "_" | <COMBININGCHAR> | <EXTENDER> >
  | < #LETTER: < BASECHAR> | <IDEOGRAMIC>>
  | < #BASECHAR: ["A"-"Z"] | ["a"-"z"] | ["\u00c0"-"\u00d6"] | ["\u00d8"-"\u00f6"] | ["\u00f8"-"\u00ff"] | ["\u0100"-"\u0131"] | ["\u0134"-"\u013e"] | ["\u0141"-"\u0148"] | ["\u014a"-"\u017e"] | ["\u0180"-"\u01c3"] | ["\u01cd"-"\u01f0"] | ["\u01f4"-"\u01f5"] | ["\u01fa"-"\u0217"] | ["\u0250"-"\u02a8"] | ["\u02bb"-"\u02c1"] | "\u0386" | ["\u0388"-"\u038a"] | "\u038c" | ["\u038e"-"\u03a1"] | ["\u03a3"-"\u03ce"] | ["\u03d0"-"\u03d6"] | "\u03da" | "\u03dc" | "\u03de" | "\u03e0" | ["\u03e2"-"\u03f3"] | ["\u0401"-"\u040c"] | ["\u040e"-"\u044f"] | ["\u0451"-"\u045c"] | ["\u045e"-"\u0481"] | ["\u0490"-"\u04c4"] | ["\u04c7"-"\u04c8"] | ["\u04cb"-"\u04cc"] | ["\u04d0"-"\u04eb"] | ["\u04ee"-"\u04f5"] | ["\u04f8"-"\u04f9"] | ["\u0531"-"\u0556"] | "\u0559" | ["\u0561"-"\u0586"] | ["\u05d0"-"\u05ea"] | ["\u05f0"-"\u05f2"] | ["\u0621"-"\u063a"] | ["\u0641"-"\u064a"] | ["\u0671"-"\u06b7"] | ["\u06ba"-"\u06be"] | ["\u06c0"-"\u06ce"] | ["\u06d0"-"\u06d3"] | "\u06d5" | ["\u06e5"-"\u06e6"] | ["\u0905"-"\u0939"] | "\u093d" | ["\u0958"-"\u0961"] | ["\u0985"-"\u098c"] | ["\u098f"-"\u0990"] | ["\u0993"-"\u09a8"] | ["\u09aa"-"\u09b0"] | "\u09b2" | ["\u09b6"-"\u09b9"] | ["\u09dc"-"\u09dd"] | ["\u09df"-"\u09e1"] | ["\u09f0"-"\u09f1"] | ["\u0a05"-"\u0a0a"] | ["\u0a0f"-"\u0a10"] | ["\u0a13"-"\u0a28"] | ["\u0a2a"-"\u0a30"] | ["\u0a32"-"\u0a33"] | ["\u0a35"-"\u0a36"] | ["\u0a38"-"\u0a39"] | ["\u0a59"-"\u0a5c"] | "\u0a5e" | ["\u0a72"-"\u0a74"] | ["\u0a85"-"\u0a8b"] | "\u0a8d" | ["\u0a8f"-"\u0a91"] | ["\u0a93"-"\u0aa8"] | ["\u0aaa"-"\u0ab0"] | ["\u0ab2"-"\u0ab3"] | ["\u0ab5"-"\u0ab9"] | "\u0abd" | "\u0ae0" | ["\u0b05"-"\u0b0c"] | ["\u0b0f"-"\u0b10"] | ["\u0b13"-"\u0b28"] | ["\u0b2a"-"\u0b30"] | ["\u0b32"-"\u0b33"] | ["\u0b36"-"\u0b39"] | "\u0b3d" | ["\u0b5c"-"\u0b5d"] | ["\u0b5f"-"\u0b61"] | ["\u0b85"-"\u0b8a"] | ["\u0b8e"-"\u0b90"] | ["\u0b92"-"\u0b95"] | ["\u0b99"-"\u0b9a"] | "\u0b9c" | ["\u0b9e"-"\u0b9f"] | ["\u0ba3"-"\u0ba4"] | ["\u0ba8"-"\u0baa"] | ["\u0bae"-"\u0bb5"] | ["\u0bb7"-"\u0bb9"] | ["\u0c05"-"\u0c0c"] | ["\u0c0e"-"\u0c10"] | ["\u0c12"-"\u0c28"] | ["\u0c2a"-"\u0c33"] | ["\u0c35"-"\u0c39"] | ["\u0c60"-"\u0c61"] | ["\u0c85"-"\u0c8c"] | ["\u0c8e"-"\u0c90"] | ["\u0c92"-"\u0ca8"] | ["\u0caa"-"\u0cb3"] | ["\u0cb5"-"\u0cb9"] | "\u0cde" | ["\u0ce0"-"\u0ce1"] | ["\u0d05"-"\u0d0c"] | ["\u0d0e"-"\u0d10"] | ["\u0d12"-"\u0d28"] | ["\u0d2a"-"\u0d39"] | ["\u0d60"-"\u0d61"] | ["\u0e01"-"\u0e2e"] | "\u0e30" | ["\u0e32"-"\u0e33"] | ["\u0e40"-"\u0e45"] | ["\u0e81"-"\u0e82"] | "\u0e84" | ["\u0e87"-"\u0e88"] | "\u0e8a" | "\u0e8d" | ["\u0e94"-"\u0e97"] | ["\u0e99"-"\u0e9f"] | ["\u0ea1"-"\u0ea3"] | "\u0ea5" | "\u0ea7" | ["\u0eaa"-"\u0eab"] | ["\u0ead"-"\u0eae"] | "\u0eb0" | ["\u0eb2"-"\u0eb3"] | "\u0ebd" | ["\u0ec0"-"\u0ec4"] | ["\u0f40"-"\u0f47"] | ["\u0f49"-"\u0f69"] | ["\u10a0"-"\u10c5"] | ["\u10d0"-"\u10f6"] | "\u1100" | ["\u1102"-"\u1103"] | ["\u1105"-"\u1107"] | "\u1109" | ["\u110b"-"\u110c"] | ["\u110e"-"\u1112"] | "\u113c" | "\u113e" | "\u1140" | "\u114c" | "\u114e" | "\u1150" | ["\u1154"-"\u1155"] | "\u1159" | ["\u115f"-"\u1161"] | "\u1163" | "\u1165" | "\u1167" | "\u1169" | ["\u116d"-"\u116e"] | ["\u1172"-"\u1173"] | "\u1175" | "\u119e" | "\u11a8" | "\u11ab" | ["\u11ae"-"\u11af"] | ["\u11b7"-"\u11b8"] | "\u11ba" | ["\u11bc"-"\u11c2"] | "\u11eb" | "\u11f0" | "\u11f9" | ["\u1e00"-"\u1e9b"] | ["\u1ea0"-"\u1ef9"] | ["\u1f00"-"\u1f15"] | ["\u1f18"-"\u1f1d"] | ["\u1f20"-"\u1f45"] | ["\u1f48"-"\u1f4d"] | ["\u1f50"-"\u1f57"] | "\u1f59" | "\u1f5b" | "\u1f5d" | ["\u1f5f"-"\u1f7d"] | ["\u1f80"-"\u1fb4"] | ["\u1fb6"-"\u1fbc"] | "\u1fbe" | ["\u1fc2"-"\u1fc4"] | ["\u1fc6"-"\u1fcc"] | ["\u1fd0"-"\u1fd3"] | ["\u1fd6"-"\u1fdb"] | ["\u1fe0"-"\u1fec"] | ["\u1ff2"-"\u1ff4"] | ["\u1ff6"-"\u1ffc"] | "\u2126" | ["\u212a"-"\u212b"] | "\u212e" | ["\u2180"-"\u2182"] | ["\u3041"-"\u3094"] | ["\u30a1"-"\u30fa"] | ["\u3105"-"\u312c"] | ["\uac00"-"\ud7a3"] >
  | < #IDEOGRAMIC: ["\u4e00"-"\u9fa5"] | "\u3007" | ["\u3021"-"\u3029"] >
  | < #XMLDIGIT: ["0"-"9"] | ["\u0660"-"\u0669"] | ["\u06f0"-"\u06f9"] | ["\u0966"-"\u096f"] | ["\u09e6"-"\u09ef"] | ["\u0a66"-"\u0a6f"] | ["\u0ae6"-"\u0aef"] | ["\u0b66"-"\u0b6f"] | ["\u0be7"-"\u0bef"] | ["\u0c66"-"\u0c6f"] | ["\u0ce6"-"\u0cef"] | ["\u0d66"-"\u0d6f"] | ["\u0e50"-"\u0e59"] | ["\u0ed0"-"\u0ed9"] | ["\u0f20"-"\u0f29"] >
  | < #EXTENDER: "\u00b7" | "\u02d0" | "\u02d1" | "\u0387" | "\u0640" | "\u0e46" | "\u0ec6" | "\u3005" | ["\u3031"-"\u3035"] | ["\u309d"-"\u309e"] | ["\u30fc"-"\u30fe"] >
  | < #COMBININGCHAR: ["\u0300"-"\u0345"] | ["\u0360"-"\u0361"] | ["\u0483"-"\u0486"] | ["\u0591"-"\u05a1"] | ["\u05a3"-"\u05b9"] | ["\u05bb"-"\u05bd"] | "\u05bf" | ["\u05c1"-"\u05c2"] | "\u05c4" | ["\u064b"-"\u0652"] | "\u0670" | ["\u06d6"-"\u06dc"] | ["\u06dd"-"\u06df"] | ["\u06e0"-"\u06e4"] | ["\u06e7"-"\u06e8"] | ["\u06ea"-"\u06ed"] | ["\u0901"-"\u0903"] | "\u093c" | ["\u093e"-"\u094c"] | "\u094d" | ["\u0951"-"\u0954"] | ["\u0962"-"\u0963"] | ["\u0981"-"\u0983"] | "\u09bc" | "\u09be" | "\u09bf" | ["\u09c0"-"\u09c4"] | ["\u09c7"-"\u09c8"] | ["\u09cb"-"\u09cd"] | "\u09d7" | ["\u09e2"-"\u09e3"] | "\u0a02" | "\u0a3c" | "\u0a3e" | "\u0a3f" | ["\u0a40"-"\u0a42"] | ["\u0a47"-"\u0a48"] | ["\u0a4b"-"\u0a4d"] | ["\u0a70"-"\u0a71"] | ["\u0a81"-"\u0a83"] | "\u0abc" | ["\u0abe"-"\u0ac5"] | ["\u0ac7"-"\u0ac9"] | ["\u0acb"-"\u0acd"] | ["\u0b01"-"\u0b03"] | "\u0b3c" | ["\u0b3e"-"\u0b43"] | ["\u0b47"-"\u0b48"] | ["\u0b4b"-"\u0b4d"] | ["\u0b56"-"\u0b57"] | ["\u0b82"-"\u0b83"] | ["\u0bbe"-"\u0bc2"] | ["\u0bc6"-"\u0bc8"] | ["\u0bca"-"\u0bcd"] | "\u0bd7" | ["\u0c01"-"\u0c03"] | ["\u0c3e"-"\u0c44"] | ["\u0c46"-"\u0c48"] | ["\u0c4a"-"\u0c4d"] | ["\u0c55"-"\u0c56"] | ["\u0c82"-"\u0c83"] | ["\u0cbe"-"\u0cc4"] | ["\u0cc6"-"\u0cc8"] | ["\u0cca"-"\u0ccd"] | ["\u0cd5"-"\u0cd6"] | ["\u0d02"-"\u0d03"] | ["\u0d3e"-"\u0d43"] | ["\u0d46"-"\u0d48"] | ["\u0d4a"-"\u0d4d"] | "\u0d57" | "\u0e31" | ["\u0e34"-"\u0e3a"] | ["\u0e47"-"\u0e4e"] | "\u0eb1" | ["\u0eb4"-"\u0eb9"] | ["\u0ebb"-"\u0ebc"] | ["\u0ec8"-"\u0ecd"] | ["\u0f18"-"\u0f19"] | "\u0f35" | "\u0f37" | "\u0f39" | "\u0f3e" | "\u0f3f" | ["\u0f71"-"\u0f84"] | ["\u0f86"-"\u0f8b"] | ["\u0f90"-"\u0f95"] | "\u0f97" | ["\u0f99"-"\u0fad"] | ["\u0fb1"-"\u0fb7"] | "\u0fb9" | ["\u20d0"-"\u20dc"] | "\u20e1" | ["\u302a"-"\u302f"] | "\u3099" | "\u309a" >
  | < CHAR: "	" [" "-"\ud7ff"] | ["\ue000"-"\ufffd"] > /*  | "
" | "" | missing !*/
}

void XPath() :
{}
{
  Expr () <EOF>
}

void Expr()                :
{/*@bgen(jjtree) #CommaExpr(> 1) */
  XPathCommaExpr jjtn000 = new XPathCommaExpr(JJTCOMMAEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #CommaExpr(> 1) */
  try {
/*@egen*/
  ExprSingle() (<COMMA> ExprSingle())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void ExprSingle() :
{}
{
  OrExpr() | ForExpr() | QuantifiedExpr() | ( IfExpr() )
}

/*
void ForExpr() #ForExpr :
{}
{
  SimpleForClause() <RETURN> ExprSingle()
}
*/

void ForExpr()          :
{/*@bgen(jjtree) ForExpr */
  XPathForExpr jjtn000 = new XPathForExpr(JJTFOREXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token qname = null;
}
{/*@bgen(jjtree) ForExpr */
  try {
/*@egen*/
  (<FOR> <DOLLAR> (qname=<QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> | qname = <TO>) <IN> ExprSingle() (SimpleForClause2())*) <RETURN> ExprSingle()/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
jjtn000.setQName(qname, nsExpander, noPrefixBehavior);
}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SimpleForClause2()                   :
{/*@bgen(jjtree) SimpleForClause2 */
  XPathSimpleForClause2 jjtn000 = new XPathSimpleForClause2(JJTSIMPLEFORCLAUSE2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token qname = null;
}
{/*@bgen(jjtree) SimpleForClause2 */
  try {
/*@egen*/
  (<COMMA> <DOLLAR> (qname=<QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> | qname = <TO>) <IN> ExprSingle())/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
jjtn000.setQName(qname, nsExpander, noPrefixBehavior);
}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void QuantifiedExpr()                 :
{/*@bgen(jjtree) QuantifiedExpr */
  XPathQuantifiedExpr jjtn000 = new XPathQuantifiedExpr(JJTQUANTIFIEDEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token qty = null;
  Token qname = null;
}
{/*@bgen(jjtree) QuantifiedExpr */
  try {
/*@egen*/
  ((qty = <SOME> | qty = <EVERY>) <DOLLAR> (qname = <QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> | qname = <TO>)
   <IN> ExprSingle() (QuantifiedExpr2())* <SATISFIES> ExprSingle())/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
  jjtn000.setQuantifier(qty.image);
  jjtn000.setQName(qname, nsExpander, noPrefixBehavior);
}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void QuantifiedExpr2()                  :
{/*@bgen(jjtree) QuantifiedExpr2 */
  XPathQuantifiedExpr2 jjtn000 = new XPathQuantifiedExpr2(JJTQUANTIFIEDEXPR2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token qname = null;
}
{/*@bgen(jjtree) QuantifiedExpr2 */
  try {
/*@egen*/
  (<COMMA> <DOLLAR> (qname = <QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> | qname = <TO>) <IN> ExprSingle())/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
  jjtn000.setQName(qname, nsExpander, noPrefixBehavior);
}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void IfExpr()         :
{/*@bgen(jjtree) IfExpr */
  XPathIfExpr jjtn000 = new XPathIfExpr(JJTIFEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfExpr */
  try {
/*@egen*/
  <IFLPAREN> Expr() <RPAREN> <THEN> ExprSingle() <ELSE> ExprSingle()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/*
 * Subclassed: OrExpr. One or more children.
 */
void OrExpr()              :
{/*@bgen(jjtree) #OrExpr(> 1) */
  XPathOrExpr jjtn000 = new XPathOrExpr(JJTOREXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #OrExpr(> 1) */
  try {
/*@egen*/
  AndExpr() ( <OR>  AndExpr())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

/*
 * Subclassed: AndExpr. One or more children.
 */
void AndExpr()              :
{/*@bgen(jjtree) #AndExpr(> 1) */
  XPathAndExpr jjtn000 = new XPathAndExpr(JJTANDEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #AndExpr(> 1) */
  try {
/*@egen*/
  ComparisonExpr() ( <AND> ComparisonExpr())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void ComparisonExpr()                    :
{/*@bgen(jjtree) #ComparisonExpr(> 1) */
  XPathComparisonExpr jjtn000 = new XPathComparisonExpr(JJTCOMPARISONEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token operator = null;
}
{/*@bgen(jjtree) #ComparisonExpr(> 1) */
 try {
/*@egen*/
 (RangeExpr()((
   operator = <EQ> | operator = <NE> | operator = <LT> | operator = <LE> | operator = <GT> | operator = <GE> |
   operator = <EQUAL> | operator = <NOTEQUAL> | operator = <LESS> | operator = <LESSOREQUAL> | operator = <GREATER> | operator = <GREATEROREQUAL>  | 
   operator = <IS> | operator = <LEFTLEFT> | operator = <RIGHTRIGHT> )
{
  jjtn000.setOperator(operator.image);
}
 RangeExpr() )?
 )/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
   }
 }
/*@egen*/
}

void RangeExpr()                :
{/*@bgen(jjtree) #RangeExpr(> 1) */
  XPathRangeExpr jjtn000 = new XPathRangeExpr(JJTRANGEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #RangeExpr(> 1) */
  try {
/*@egen*/ 
  AdditiveExpr() ( <TO> AdditiveExpr() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void AdditiveExpr()                    : 
{/*@bgen(jjtree) #AdditiveExpr(> 1) */
  XPathAdditiveExpr jjtn000 = new XPathAdditiveExpr(JJTADDITIVEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token operator = null;
}
{/*@bgen(jjtree) #AdditiveExpr(> 1) */
  try {
/*@egen*/
  MultiplicativeExpr() (( operator = <PLUS> { jjtn000.addOperator(operator.image); } | operator = <MINUS> { jjtn000.addOperator(operator.image); } ) MultiplicativeExpr())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void MultiplicativeExpr()                          :
{/*@bgen(jjtree) #MultiplicativeExpr(> 1) */
  XPathMultiplicativeExpr jjtn000 = new XPathMultiplicativeExpr(JJTMULTIPLICATIVEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token operator = null;
}
{/*@bgen(jjtree) #MultiplicativeExpr(> 1) */
  try {
/*@egen*/
  UnionExpr() (( operator = <STAR> { jjtn000.addOperator(operator.image); } | operator = <DIV> { jjtn000.addOperator(operator.image); } | operator = <IDIV> { jjtn000.addOperator(operator.image); } | operator = <MOD> { jjtn000.addOperator(operator.image); } ) UnionExpr())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void UnionExpr()                :
{/*@bgen(jjtree) #UnionExpr(> 1) */
  XPathUnionExpr jjtn000 = new XPathUnionExpr(JJTUNIONEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #UnionExpr(> 1) */
  try {
/*@egen*/ 
  IntersectExceptExpr() ((<UNION> | <PIPE>) IntersectExceptExpr())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void IntersectExceptExpr()                           :
{/*@bgen(jjtree) #IntersectExceptExpr(> 1) */
  XPathIntersectExceptExpr jjtn000 = new XPathIntersectExceptExpr(JJTINTERSECTEXCEPTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token operator;
}
{/*@bgen(jjtree) #IntersectExceptExpr(> 1) */
  try {
/*@egen*/
  InstanceofExpr() ((operator = <INTERSECT> {jjtn000.addOperator(operator.image);} | operator = <EXCEPT> {jjtn000.addOperator(operator.image);} ) 
  InstanceofExpr() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

/*
 * gider ikke
 */
void InstanceofExpr()                     :
{/*@bgen(jjtree) #InstanceOfExpr(> 1) */
  XPathInstanceOfExpr jjtn000 = new XPathInstanceOfExpr(JJTINSTANCEOFEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #InstanceOfExpr(> 1) */
  try {
/*@egen*/
  TreatExpr() ( <INSTANCE> <OF> SequenceType() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void TreatExpr()                 :
{/*@bgen(jjtree) #TreatAsExpr(> 1) */
  XPathTreatAsExpr jjtn000 = new XPathTreatAsExpr(JJTTREATASEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #TreatAsExpr(> 1) */
  try {
/*@egen*/ 
  CastableExpr() ( <TREAT> <AS> SequenceType() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void CastableExpr()                   :
{/*@bgen(jjtree) #CastableExpr(> 1) */
  XPathCastableExpr jjtn000 = new XPathCastableExpr(JJTCASTABLEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #CastableExpr(> 1) */
  try {
/*@egen*/
  CastExpr() ( <CASTABLE> <AS> SingleType() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

void CastExpr()               :
{/*@bgen(jjtree) #CastExpr(> 1) */
  XPathCastExpr jjtn000 = new XPathCastExpr(JJTCASTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #CastExpr(> 1) */
  try {
/*@egen*/
  UnaryExpr() ( <CAST> <AS> SingleType() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
}

/*
 * This is not quite true to the grammar, but, heck, it only disallows really silly
 * things like writing --+++--27 (who would ever want to do that anyway?).
 */
void UnaryExpr() :
{
  Token sign;
}
{
  (/*@bgen(jjtree) UnaryExpr */
   {
     XPathUnaryExpr jjtn001 = new XPathUnaryExpr(JJTUNARYEXPR);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/((sign = <MINUS> | sign=<PLUS>) PathExpr()/*@bgen(jjtree)*/
                                              {
                                                jjtree.closeNodeScope(jjtn001, true);
                                                jjtc001 = false;
                                              }
/*@egen*/ {jjtn001.setSign(sign.image);})/*@bgen(jjtree)*/
   } catch (Throwable jjte001) {
     if (jjtc001) {
       jjtree.clearNodeScope(jjtn001);
       jjtc001 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte001 instanceof RuntimeException) {
       throw (RuntimeException)jjte001;
     }
     if (jjte001 instanceof ParseException) {
       throw (ParseException)jjte001;
     }
     throw (Error)jjte001;
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, true);
     }
   }
/*@egen*/ ) | PathExpr()
}

void PathExpr() :
{}
{/*@bgen(jjtree) AbsolutePathExpr */
    {
      XPathAbsolutePathExpr jjtn001 = new XPathAbsolutePathExpr(JJTABSOLUTEPATHEXPR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (<SLASH> (AbsolutePathExpr())?)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/ 
  |/*@bgen(jjtree) AbsolutePathExpr */
    {
      XPathAbsolutePathExpr jjtn002 = new XPathAbsolutePathExpr(JJTABSOLUTEPATHEXPR);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/ (<SLASHSLASH> (GenerateDOSNode() AbsolutePathExpr()))/*@bgen(jjtree)*/
    } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        throw (RuntimeException)jjte002;
      }
      if (jjte002 instanceof ParseException) {
        throw (ParseException)jjte002;
      }
      throw (Error)jjte002;
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
      }
    }
/*@egen*/ 
  | RelativePathExpr()
}

/* This represents either of:
 * 1) A name test with no wildcards, with or without an explicit axis. The axis must be sniffed up somehow.
 * 2) Half of a function call
 */
void QNamePathPart() :
{
  Token qname;
}
{
  (qname = <QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> | qname = <TO>)  ((<LPAREN> FunctionCallMinusNameAndLParen(qname)) | ChildStepWithNameTest(qname))
}

void FunctionCallMinusNameAndLParen(Token qname)                   :
{/*@bgen(jjtree) FunctionCallExpr */
  XPathFunctionCallExpr jjtn000 = new XPathFunctionCallExpr(JJTFUNCTIONCALLEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionCallExpr */
  try {
/*@egen*/
  ((ExprSingle() (<COMMA> ExprSingle())*)? <RPAREN> PredicateList())/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{ 
  jjtn000.setQName(qname, nsExpander, noPrefixBehavior); 
}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ChildStepWithNameTest(Token qname)           :
{/*@bgen(jjtree) AxisStep */
  XPathAxisStep jjtn000 = new XPathAxisStep(JJTAXISSTEP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AxisStep */
try {
/*@egen*/
QNameTest(qname) PredicateList()/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{jjtn000.fixupDefaultAxis();}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void QNameTest(Token qname)           :
{/*@bgen(jjtree) NameTest */
  XPathNameTest jjtn000 = new XPathNameTest(JJTNAMETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NameTest */
try {
/*@egen*//*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
jjtn000.setQName(qname, nsExpander, noPrefixBehavior);
}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

/*
 * This represents any AxisStep or FilterExpr that is not a QNamePathPart.
 */
void NonQNamePathPart() :
{}
{
  NonQNameAxisStep() | NonQNamePrimaryExpr()
}

void PathPart() :
{}
{
  QNamePathPart() | NonQNamePathPart()
}

/*
 * This nonterminal added for ease of distinction
 */
void AbsolutePathExpr() :
{}
{
  PathPart()
  ((<SLASH> (PathPart())) | (<SLASHSLASH> GenerateDOSNode() (PathPart())))*
}

void RelativePathExpr() :
{}
{/*@bgen(jjtree) #RelativePathExpr( ( jjtree . peekNode ( ) instanceof XPathAxisStep ) || ( jjtree . nodeArity ( ) > 1 )) */
{
  XPathRelativePathExpr jjtn001 = new XPathRelativePathExpr(JJTRELATIVEPATHEXPR);
  boolean jjtc001 = true;
  jjtree.openNodeScope(jjtn001);
}
try {
/*@egen*/
(
  PathPart()
  (
    (<SLASH> PathPart()) | (<SLASHSLASH> GenerateDOSNode() PathPart())
  )*
)/*@bgen(jjtree)*/
} catch (Throwable jjte001) {
  if (jjtc001) {
    jjtree.clearNodeScope(jjtn001);
    jjtc001 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte001 instanceof RuntimeException) {
    throw (RuntimeException)jjte001;
  }
  if (jjte001 instanceof ParseException) {
    throw (ParseException)jjte001;
  }
  throw (Error)jjte001;
} finally {
  if (jjtc001) {
    jjtree.closeNodeScope(jjtn001,  ( jjtree . peekNode ( ) instanceof XPathAxisStep ) || ( jjtree . nodeArity ( ) > 1 ));
  }
}
/*@egen*/
}

void NonQNameAxisStep() : 
{
}
{
  (  
    ExplicitAxisNodeTest()
  )
  |/*@bgen(jjtree) AxisStep */
  {
    XPathAxisStep jjtn001 = new XPathAxisStep(JJTAXISSTEP);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/ 
  ( 
    (( KindTest() | WildcardNameTest()) PredicateList())/*@bgen(jjtree)*/
                                                         {
                                                           jjtree.closeNodeScope(jjtn001, true);
                                                           jjtc001 = false;
                                                         }
/*@egen*/ {jjtn001.fixupDefaultAxis();}
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/
  |/*@bgen(jjtree) AxisStep */
  {
    XPathAxisStep jjtn002 = new XPathAxisStep(JJTAXISSTEP);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
  }
  try {
/*@egen*/ 
  ( 
   (<AQUANR> NodeTest() PredicateList())/*@bgen(jjtree)*/
                                         {
                                           jjtree.closeNodeScope(jjtn002, true);
                                           jjtc002 = false;
                                         }
/*@egen*/ {jjtn002.setAxis(XPathAxisStep.ATTRIBUTE);}
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte002) {
    if (jjtc002) {
      jjtree.clearNodeScope(jjtn002);
      jjtc002 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte002 instanceof RuntimeException) {
      throw (RuntimeException)jjte002;
    }
    if (jjte002 instanceof ParseException) {
      throw (ParseException)jjte002;
    }
    throw (Error)jjte002;
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
    }
  }
/*@egen*/
  |/*@bgen(jjtree) AxisStep */
  {
    XPathAxisStep jjtn003 = new XPathAxisStep(JJTAXISSTEP);
    boolean jjtc003 = true;
    jjtree.openNodeScope(jjtn003);
  }
  try {
/*@egen*/ 
  ( 
   (<DOTDOT> GenerateNode() PredicateList())/*@bgen(jjtree)*/
                                             {
                                               jjtree.closeNodeScope(jjtn003, true);
                                               jjtc003 = false;
                                             }
/*@egen*/ {jjtn003.setAxis(XPathAxisStep.PARENT); }
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte003) {
    if (jjtc003) {
      jjtree.clearNodeScope(jjtn003);
      jjtc003 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte003 instanceof RuntimeException) {
      throw (RuntimeException)jjte003;
    }
    if (jjte003 instanceof ParseException) {
      throw (ParseException)jjte003;
    }
    throw (Error)jjte003;
  } finally {
    if (jjtc003) {
      jjtree.closeNodeScope(jjtn003, true);
    }
  }
/*@egen*/
}

void GenerateNode()              :
{/*@bgen(jjtree) AnyNodeTest */
  XPathAnyNodeTest jjtn000 = new XPathAnyNodeTest(JJTANYNODETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AnyNodeTest */
try {
/*@egen*//*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

/*
 * Generate a descendant-or-self::node() without consuming anything
 */
void GenerateDOSNode()           :
{/*@bgen(jjtree) AxisStep */
  XPathAxisStep jjtn000 = new XPathAxisStep(JJTAXISSTEP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AxisStep */
try {
/*@egen*/
GenerateNode()
PredicateList()/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
jjtn000.setAxis(XPathAxisStep.DESCENDANT_OR_SELF);
}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}


void ExplicitAxisNodeTest()           :
{/*@bgen(jjtree) AxisStep */
 XPathAxisStep jjtn000 = new XPathAxisStep(JJTAXISSTEP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/short a;}
{/*@bgen(jjtree) AxisStep */
 try {
/*@egen*/
 (
  (
    (<CHILD_AXIS> {a = XPathAxisStep.CHILD;})
  | (<DESCENDANT_AXIS> {a = XPathAxisStep.DESCENDANT;})
  | (<ATTRIBUTE_AXIS> {a = XPathAxisStep.ATTRIBUTE;})
  | (<SELF_AXIS> {a = XPathAxisStep.SELF;})
  | (<DESCENDANT_OR_SELF_AXIS> {a = XPathAxisStep.DESCENDANT_OR_SELF;})
  | (<FOLLOWING_SIBLING_AXIS> {a = XPathAxisStep.FOLLOWING_SIBLING;})
  | (<FOLLOWING_AXIS> {a = XPathAxisStep.FOLLOWING;})
  | (<NAMESPACE_AXIS> {a = XPathAxisStep.NAMESPACE;})
  | (<PARENT_AXIS> {a = XPathAxisStep.PARENT;})
  | (<ANCESTOR_AXIS> {a = XPathAxisStep.ANCESTOR;})
  | (<PRECEDING_SIBLING_AXIS> {a = XPathAxisStep.PRECEDING_SIBLING;})
  | (<PRECEDING_AXIS> {a = XPathAxisStep.PRECEDING;})
  | (<ANCESTOR_OR_SELF_AXIS> {a = XPathAxisStep.ANCESTOR_OR_SELF;})
  )
  NodeTest()
  PredicateList()
 )/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/ {jjtn000.setAxis(a);}/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void NodeTest() :
{}
{
  NameTest() | KindTest()
}

void NameTest() :
{
  Token qname;
}
{
  (( token = <QNAME> | token = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> | qname = <TO>  ) QNameTest(token)) | WildcardNameTest()
}

void WildcardNameTest()           :
{/*@bgen(jjtree) NameTest */
  XPathNameTest jjtn000 = new XPathNameTest(JJTNAMETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token wc;
}
{/*@bgen(jjtree) NameTest */
  try {
/*@egen*/
  (( wc = <ANYLOCALNAME> ) | ( wc = <ANYNAMESPACENAME> ) | ( wc = <STAR> ))/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
jjtn000.setQName(wc, nsExpander, noPrefixBehavior);
}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Predicate() :
{}
{
  <LBRACKET> Expr() <RBRACKET>
}

void NonQNamePrimaryExpr() :
{}
{
  Literal() | ContextItemExpr() | VarRef() | ParenthesizedExpr()
}

void Literal() :
{}
{
  NumericLiteral() | StringLiteral()
}

void NumericLiteral() :
{}
{
  IntegerLiteral() | DecimalLiteral() | DoubleLiteral()
}

void VarRef()         :
{/*@bgen(jjtree) VarRef */
  XPathVarRef jjtn000 = new XPathVarRef(JJTVARREF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token qname;
}
{/*@bgen(jjtree) VarRef */
  try {
/*@egen*/
  <DOLLAR> (qname = <QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> | qname = <TO> ) PredicateList()/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
try {
jjtn000.setQName(qname, nsExpander, noPrefixBehavior);
} catch (Exception ex) {
RuntimeException ex2 = new RuntimeException(ex);
throw ex2;
}
}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ParenthesizedExpr()                    :
{/*@bgen(jjtree) ParenthesizedExpr */
  XPathParenthesizedExpr jjtn000 = new XPathParenthesizedExpr(JJTPARENTHESIZEDEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParenthesizedExpr */
  try {
/*@egen*/
  <LPAREN> (Expr() <RPAREN> | (<RPAREN>)) PredicateList()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ContextItemExpr()           :
{/*@bgen(jjtree) AxisStep */
  XPathAxisStep jjtn000 = new XPathAxisStep(JJTAXISSTEP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AxisStep */
  try {
/*@egen*/
  ( <DOT> GenerateNode() PredicateList() )/*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn000, true);
                                             jjtc000 = false;
                                           }
/*@egen*/ {jjtn000.setAxis(XPathAxisStep.SELF);}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/*
 * Wee need this pretty much only for distinguishing between arguments and predicates on functions ...
 */
void PredicateList()                :
{/*@bgen(jjtree) PredicateList */
  XPathPredicateList jjtn000 = new XPathPredicateList(JJTPREDICATELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PredicateList */
  try {
/*@egen*/
  (Predicate())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/*
 * Hvad er det?
 */
void SingleType()             :
{/*@bgen(jjtree) SingleType */
  XPathSingleType jjtn000 = new XPathSingleType(JJTSINGLETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token qname = null;
  Token nillable = null;
}
{/*@bgen(jjtree) SingleType */
  try {
/*@egen*/
  (( qname = <QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> | qname = <TO>) ( nillable = <QUESTION>)?)/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
  jjtn000.setQName(qname, nsExpander, noPrefixBehavior);
  if (nillable!=null)
    jjtn000.setNillable();
}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SequenceType() :
{
  Token c = null;
}
{
  (/*@bgen(jjtree) EmptySequenceType */
   {
     XPathEmptySequenceType jjtn001 = new XPathEmptySequenceType(JJTEMPTYSEQUENCETYPE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
   }
   try {
/*@egen*/(<EMPTY_SEQUENCELPAREN> <RPAREN> )/*@bgen(jjtree)*/
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, true);
     }
   }
/*@egen*/) | 
  (/*@bgen(jjtree) ItemType */
   {
     XPathItemType jjtn002 = new XPathItemType(JJTITEMTYPE);
     boolean jjtc002 = true;
     jjtree.openNodeScope(jjtn002);
   }
   try {
/*@egen*/((ItemType() 
   ( c = <QUESTION> | c = <STAR> | c = <PLUS> )?)/*@bgen(jjtree)*/
                                                  {
                                                    jjtree.closeNodeScope(jjtn002, true);
                                                    jjtc002 = false;
                                                  }
/*@egen*/ { jjtn002.setCard(c);} )/*@bgen(jjtree)*/
   } catch (Throwable jjte002) {
     if (jjtc002) {
       jjtree.clearNodeScope(jjtn002);
       jjtc002 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte002 instanceof RuntimeException) {
       throw (RuntimeException)jjte002;
     }
     if (jjte002 instanceof ParseException) {
       throw (ParseException)jjte002;
     }
     throw (Error)jjte002;
   } finally {
     if (jjtc002) {
       jjtree.closeNodeScope(jjtn002, true);
     }
   }
/*@egen*/ )
}

void ItemType() :
{}
{ 
  KindTest() |/*@bgen(jjtree) ItemTest */
               {
                 XPathItemTest jjtn001 = new XPathItemTest(JJTITEMTEST);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
               }
               try {
/*@egen*/ (<ITEMLPAREN> <RPAREN>)/*@bgen(jjtree)*/
               } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001, true);
                 }
               }
/*@egen*/ | QNamedType()
}

void QNamedType()           :
{/*@bgen(jjtree) NameTest */
  XPathNameTest jjtn000 = new XPathNameTest(JJTNAMETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token qname = null;
}
{/*@bgen(jjtree) NameTest */
  try {
/*@egen*/
  (qname = <QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> | qname = <TO>  )/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
  jjtn000.setQName(qname, nsExpander, noPrefixBehavior);
}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void KindTest() :
{}
{
    DocumentTest()
  | ElementTest() 
  | AttributeTest()
  | SchemaElementTest()
  | SchemaAttributeTest()
  | PITest()
  | CommentTest()
  | TextTest()
  | AnyKindTest()
}

void AnyKindTest()              :
{/*@bgen(jjtree) AnyNodeTest */
  XPathAnyNodeTest jjtn000 = new XPathAnyNodeTest(JJTANYNODETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AnyNodeTest */
  try {
/*@egen*/
  <NODELPAREN> <RPAREN>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DocumentTest()               :
{/*@bgen(jjtree) DocumentTest */
  XPathDocumentTest jjtn000 = new XPathDocumentTest(JJTDOCUMENTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DocumentTest */
  try {
/*@egen*/
  (<DOCUMENT_NODELPAREN> (ElementTest() | SchemaElementTest())? <RPAREN>)/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void TextTest()           :
{/*@bgen(jjtree) TextTest */
  XPathTextTest jjtn000 = new XPathTextTest(JJTTEXTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TextTest */
  try {
/*@egen*/
  <TEXTLPARENRPAREN>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CommentTest()              :
{/*@bgen(jjtree) CommentTest */
  XPathCommentTest jjtn000 = new XPathCommentTest(JJTCOMMENTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CommentTest */
  try {
/*@egen*/
  (<COMMENTLPAREN> <RPAREN>)/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/*
 * TODO: Throw exc if non-NCNAME QNAME
 */
void PITest()         :
{/*@bgen(jjtree) PITest */
  XPathPITest jjtn000 = new XPathPITest(JJTPITEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token target = null;
}
{/*@bgen(jjtree) PITest */
try {
/*@egen*/
(
  <PROCESSING_INSTRUCTIONLPAREN>
  ((target = <QNAME> | target = <DIV> | target = <ELSE> | target = <THEN> | target = <RETURN> | target = <TO>) | ( target = <STRINGLITERAL> ))?
  <RPAREN>
)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ { jjtn000.setTarget (target==null ? null : target.image); }/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void SchemaAttributeTest()                       :
{/*@bgen(jjtree) SchemaAttributeTest */
  XPathSchemaAttributeTest jjtn000 = new XPathSchemaAttributeTest(JJTSCHEMAATTRIBUTETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token qname = null;
}
{/*@bgen(jjtree) SchemaAttributeTest */
  try {
/*@egen*/
  <SCHEMA_ATTRIBUTELPAREN> (qname = <QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> |qname = <TO>) <RPAREN>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/ 
{
  jjtn000.setQName(qname, nsExpander, noPrefixBehavior);
}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ElementTest()              :
{/*@bgen(jjtree) ElementTest */
XPathElementTest jjtn000 = new XPathElementTest(JJTELEMENTTEST);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/ 
boolean localNameStar = false;
boolean nillable = false;
Token qname = null;
Token typeqname = null;
}
{/*@bgen(jjtree) ElementTest */
  try {
/*@egen*/
  <ELEMENTLPAREN> 
((((qname = <QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> ) {localNameStar = false;} ) | (<STAR> {localNameStar = true;}))
   (<COMMA> (( typeqname = <QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> | qname = <TO>)) ( <QUESTION> {nillable=true;})?)?
  <RPAREN>)/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
if (localNameStar) {
jjtn000.setQName("*", nsExpander, noPrefixBehavior);
} else if (qname!=null) {
jjtn000.setQName(qname, nsExpander, noPrefixBehavior);
} else jjtn000.setQName("*", nsExpander, noPrefixBehavior);
if (typeqname!=null)
jjtn000.setTypeQName(typeqname, nsExpander, noPrefixBehavior);
if(nillable) {
jjtn000.setNillable(true);
}
}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AttributeTest()                :
{/*@bgen(jjtree) AttributeTest */
XPathAttributeTest jjtn000 = new XPathAttributeTest(JJTATTRIBUTETEST);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/ 
boolean localNameStar = false;
boolean nillable = false;
Token qname = null;
Token typeqname = null;
}
{/*@bgen(jjtree) AttributeTest */
  try {
/*@egen*/
  <ATTRIBUTELPAREN> 
((((qname = <QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> | qname = <TO>) {localNameStar = false;} ) | (<STAR> {localNameStar = true;}))
   (<COMMA> ((typeqname = <QNAME> | typeqname = <DIV> | typeqname = <ELSE> | typeqname = <THEN> | typeqname = <RETURN> | typeqname = <TO>)))?
  <RPAREN>)/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
if (localNameStar) {
jjtn000.setQName("*", nsExpander, noPrefixBehavior);
} else {
jjtn000.setQName(qname, nsExpander, noPrefixBehavior);
}
if (typeqname!=null) {
jjtn000.setQName(typeqname, nsExpander, noPrefixBehavior);
}
}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SchemaElementTest()                    :
{/*@bgen(jjtree) SchemaElementTest */
  XPathSchemaElementTest jjtn000 = new XPathSchemaElementTest(JJTSCHEMAELEMENTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token qname;
}
{/*@bgen(jjtree) SchemaElementTest */
  try {
/*@egen*/
  (<SCHEMA_ELEMENTLPAREN> (qname = <QNAME> | qname = <DIV> | qname = <ELSE> | qname = <THEN> | qname = <RETURN> | qname = <TO>) <RPAREN>)/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
jjtn000.setQName(qname, nsExpander, noPrefixBehavior);
}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/*
 * Type could be sharpened if desired.
 */
void IntegerLiteral()                 :
{/*@bgen(jjtree) NumericLiteral */
  XPathNumericLiteral jjtn000 = new XPathNumericLiteral(JJTNUMERICLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token content = null;
}
{/*@bgen(jjtree) NumericLiteral */
try {
/*@egen*/
(( content = <DIGITS> ) PredicateList())/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
  jjtn000.setContent(content.image);
}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

/*
 * Type could be sharpened if desired.
 */
void DecimalLiteral()                 :
{/*@bgen(jjtree) NumericLiteral */
  XPathNumericLiteral jjtn000 = new XPathNumericLiteral(JJTNUMERICLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token content = null;
}
{/*@bgen(jjtree) NumericLiteral */
try {
/*@egen*/
(( content = <DECIMAL> ) PredicateList() )/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
  jjtn000.setContent(content.image);
}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

/*
 * Type could be sharpened if desired.
 */
void DoubleLiteral()                 :
{/*@bgen(jjtree) NumericLiteral */
  XPathNumericLiteral jjtn000 = new XPathNumericLiteral(JJTNUMERICLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token content = null;
}
{/*@bgen(jjtree) NumericLiteral */
try {
/*@egen*/
(
  ((content = <DOUBLE>) PredicateList())
)/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{
  jjtn000.setContent(content.image);
}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void StringLiteral()                :
{/*@bgen(jjtree) StringLiteral */
  XPathStringLiteral jjtn000 = new XPathStringLiteral(JJTSTRINGLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token content;
}
{/*@bgen(jjtree) StringLiteral */
try {
/*@egen*/
( 
  ((content = <STRINGLITERAL>) PredicateList())
)/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {jjtn000.setContent(content.image);}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/ 
}

/* TODO: Make this work
void Comment() :
{}
{
  <LSMILEY> (CommentContents() | Comment())* <RSMILEY>
}

void CommentContents() :
{}
{
  (<CHAR>)+ 
}
*/
