/* Generated By:JJTree: Do not edit this line. XPathAttributeTest.java */

package dongfang.xsltools.xpath2;

import java.util.Set;

import org.dom4j.DocumentFactory;
import org.dom4j.Element;
import org.dom4j.QName;

import dongfang.xsltools.exceptions.XSLToolsRuntimeException;
import dongfang.xsltools.exceptions.XSLToolsXPathUnresolvedNamespaceException;
import dongfang.xsltools.model.NamespaceExpander;

public abstract class XPathQNamedTypedNodeTest extends XPathQNamedNodeTest {
  QName typeQName;

  public XPathQNamedTypedNodeTest(int id) {
    super(id);
  }

  public XPathQNamedTypedNodeTest(XPathParser p, int id) {
    super(p, id);
  }

  abstract String getKindName();

  /*
   * void copyTypeQName() { XPathTempQName q = (XPathTempQName)jjtGetChild(0);
   * this.typeQName = q.getQName(); // this.isMultiple = q.isMultiple(); //
   * remove the temp-qname node Node[] ch = new Node[jjtGetNumChildren()-1];
   * System.arraycopy(children, 1, ch, 0, ch.length); this.children = ch; }
   */

  void setTypeQName(String qname, NamespaceExpander expander, String npb) {
    int cix = qname.indexOf(':');
    if (cix >= 0) {
      String prefix = qname.substring(0, cix);
      String local = qname.substring(cix + 1);
      if ("*".equals(prefix)) {
        isMultiple = true;
        this.typeQName = QName.get(local, prefix, "*");
      } else {
        isMultiple = "*".equals(local);
        try {
          this.typeQName = expander.getQNameFromString(qname, npb);
        } catch (XSLToolsXPathUnresolvedNamespaceException ex) {
          throw new XSLToolsRuntimeException(ex);
        }
      }
    } else {
      if ("*".equals(qname)) {
        isMultiple = true;
        this.typeQName = QName.get("*", "", "*"); // For binding of default to
        // non null URI, alter this.
      } else {
        this.typeQName = QName.get(qname); // For binding of default to non
        // null URI, alter this.
      }
    }
  }

  void setTypeQName(Token qnameT, NamespaceExpander expander, String npb) {
    setTypeQName(qnameT.image, expander, npb);
  }

  /*
   * void setTypeQName(String prefix, String localName, NamespaceExpander
   * expander) throws XSLToolsXPathUnresolvedNamespaceException { if
   * ("".equals(localName)) { typeQName = null; return; } String total =
   * "".equals(prefix) ? localName : prefix+':'+localName; / * will this ever
   * happen?? Never mind, leave test * / if ("*".equals(prefix)) typeQName =
   * QName.get(localName, "", "*"); else typeQName =
   * expander.getQNameFromString(total,
   * NamespaceExpander.BIND_PREFIXLESS_TO_NO_NAMESPACE); }
   * 
   * void setTypeQName(Token prefixT, Token localNameT, NamespaceExpander
   * expander) throws XSLToolsXPathUnresolvedNamespaceException { String prefix =
   * prefixT==null ? "" : prefixT.image; String localName = localNameT==null ? "" :
   * localNameT.image; setTypeQName(prefix, localName, expander); }
   */

  QName getTypeName() {
    return typeQName;
  }

  @Override
public String toString() {
    StringBuilder res = new StringBuilder();
    res.append(getKindName());
    res.append("(");
    res.append(super.toString());
    if (typeQName != null) {
      res.append(",");
      res.append(typeQName.getQualifiedName());
    }
    res.append(")");
    return res.toString();
  }

  @Override
  public void moreDiagnostics(Element me, DocumentFactory fac, Set<Object> configuration) {
    super.moreDiagnostics(me, fac, configuration);
    me.addAttribute("typeQName", typeQName == null ? "null" : typeQName
        .getQualifiedName());
  }
}
