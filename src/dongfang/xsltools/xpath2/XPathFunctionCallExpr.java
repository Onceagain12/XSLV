/* Generated By:JJTree: Do not edit this line. XPathFunctionCallExpr.java */

package dongfang.xsltools.xpath2;

import java.util.Iterator;

import org.dom4j.QName;

import dongfang.xsltools.exceptions.XSLToolsException;

public class XPathFunctionCallExpr extends XPathQNameExprBase implements
    XPathFilterExpr {
  public XPathFunctionCallExpr(int id) {
    super(id);
  }

  public XPathFunctionCallExpr(XPathParser p, int id) {
    super(p, id);
  }

  public XPathFunctionCallExpr(QName name) {
    this(0);
    setQName(name);
  }

  @Override
public XPathBase accept(XPathVisitor v) throws XSLToolsException {
    return v.visit(this);
  }

  private XPathPredicateList getPredicateList() {
    return (XPathPredicateList) jjtGetChild(jjtGetNumChildren() - 1);
  }

  public boolean hasPredicates() {
    XPathPredicateList l = getPredicateList();
    return l.hasPredicates();
  }

  public Iterator<XPathExpr> predicates() {
    XPathPredicateList l = getPredicateList();
    return l.predicates();
  }

  public void addEmptyPredicateList() {
    jjtAddChild(new XPathPredicateList(), jjtGetNumChildren());
  }

  public int arity() {
    return jjtGetNumChildren() - 1;
  }

  public XPathExpr getArgument(int i) {
    return (XPathExpr) jjtGetChild(i);
  }

  public void addArgument(XPathExpr expr) {
    int arity = arity() + 1;
    // Node predicateList = getPredicateList();
    jjtAddChild((Node) expr, arity);
    // jjtAddChild(predicateList, arity + 1);
  }

  public short getType() {
    return TYPE_ANY; // TODO: Ask the function.
  }

  @Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(qname.getQualifiedName());
    sb.append("(");
    int i;
    boolean needsComma = false;
    for (i = 0; i < jjtGetNumChildren() - 1; i++) {
      if (needsComma)
        sb.append(",");
      else
        needsComma = true;
      sb.append(jjtGetChild(i).toString());
    }
    sb.append(")");
    sb.append(jjtGetChild(i).toString());
    return sb.toString();
  }
}
