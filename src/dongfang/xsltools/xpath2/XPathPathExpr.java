/* Generated By:JJTree: Do not edit this line. XPathPathExpr.java */

package dongfang.xsltools.xpath2;

import java.util.Iterator;

import org.dom4j.QName;

import dongfang.xsltools.exceptions.XSLToolsException;
import dongfang.xsltools.exceptions.XSLToolsXPathException;
import dongfang.xsltools.util.Dom4jUtil;

public abstract class XPathPathExpr extends XPathBase implements Cloneable,
    Iterable<XPathStepExpr>, XPathExpr {
  public XPathPathExpr(int id) {
    super(id);
  }

  public XPathPathExpr(XPathParser p, int id) {
    super(p, id);
  }

  public XPathPathExpr() {
    this(0);
  }

  @Override
public XPathBase accept(XPathVisitor v) throws XSLToolsException {
    return v.visit(this);
  }

  @Override
public Object clone() {
    XPathPathExpr clone = (XPathPathExpr) super.clone();
    if (clone.children != null)
      clone.children = clone.children.clone();
    return clone;
  }

  public boolean hasPredicates() {
    // Check each step:
    int i = 0;
    while (i < jjtGetNumChildren()) {
      Object o = jjtGetChild(i++);

      if (o instanceof XPathStepExpr && ((XPathStepExpr) o).hasPredicates())
        return true;
    }
    // None of the steps had a predicate:
    return false;
  }

  public Iterator<XPathStepExpr> steps() {
    return new Iterator<XPathStepExpr>() {
      int n = jjtGetNumChildren();

      int i = 0;

      public boolean hasNext() {
        return i < n;
      }

      public XPathStepExpr next() {
        try {
          return (XPathStepExpr) jjtGetChild(i++);
        } catch (ClassCastException ex) {
          System.err.println(Dom4jUtil.diagnostics(XPathPathExpr.this));
          throw ex;
        }
      }

      public void remove() {
      }
    };
  }

  public Iterator<XPathStepExpr> reverseSteps() {
    return new Iterator<XPathStepExpr>() {
      int i = jjtGetNumChildren() - 1;

      public boolean hasNext() {
        return i >= 0;
      }

      public XPathStepExpr next() {
        try {
          return (XPathStepExpr) jjtGetChild(i--);
        } catch (ClassCastException ex) {
          System.err.println(Dom4jUtil.diagnostics(XPathPathExpr.this));
          throw ex;
        }
      }

      public void remove() {
      }
    };
  }

  public XPathExpr getFirstStep() throws XSLToolsXPathException {
    if (jjtGetNumChildren() == 0)
      throw new XSLToolsXPathException(
          "First step requested, but we don't have any");
    return (XPathExpr) jjtGetChild(0);
  }

  public XPathExpr getLastStep() throws XSLToolsXPathException {
    if (jjtGetNumChildren() == 0)
      throw new XSLToolsXPathException(
          "Last step requested, but we don't have any");
    return (XPathExpr) jjtGetChild(jjtGetNumChildren() - 1);
  }

  public void addStepAtHead(XPathBase step) {
    if (children == null) {
      children = new Node[1];
    } else {
      Node c[] = new Node[jjtGetNumChildren() + 1];
      System.arraycopy(children, 0, c, 1, children.length);
      children = c;
    }
    children[0] = step;
  }

  public void addLastStep(XPathBase step) {
    if (children == null) {
      children = new Node[1];
    } else {
      Node c[] = new Node[jjtGetNumChildren() + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[jjtGetNumChildren() - 1] = step;
  }

  public void replaceLastStep(XPathBase step) {
    jjtAddChild(step, jjtGetNumChildren() - 1);
  }

  public void removeLastStep() {
    Node c[] = new Node[jjtGetNumChildren() - 1];
    System.arraycopy(children, 0, c, 0, c.length);
    children = c;
  }

  public void addStepsFrom(XPathPathExpr other) {
    int o = getStepCount();

    // extend array only once...
    if (other.getStepCount() > 0)
      jjtAddChild(null, getStepCount() + other.getStepCount() - 1);

    for (int i = 0; i < other.getStepCount(); i++) {
      jjtAddChild(other.jjtGetChild(i), o + i);
    }
  }

  public static XPathPathExpr concatenation(XPathPathExpr first,
      XPathPathExpr second) {
    XPathPathExpr result;
    if (second instanceof XPathAbsolutePathExpr)
      return (XPathPathExpr) second.clone();
    result = (XPathPathExpr) first.clone();
    result.addStepsFrom(second);
    return result;
  }

  public XPathPathExpr concatenation(XPathPathExpr other) {
    return concatenation(this, other);
  }

  public int getStepCount() {
    return jjtGetNumChildren();
  }

  public Iterator<XPathStepExpr> iterator() {
    return new Iterator<XPathStepExpr>() {
      int i = 0;

      public boolean hasNext() {
        return i < jjtGetNumChildren();
      }

      public XPathStepExpr next() {
        try {
          return (XPathStepExpr) jjtGetChild(i++);
        } catch (ClassCastException ex) {
          System.err.println(Dom4jUtil.diagnostics(XPathPathExpr.this));
          throw ex;
        }
      }

      public void remove() {
        throw new UnsupportedOperationException();
      }
    };
  }

  public double defaultPriority() {
    // absolute path exprs handled in that class...
    // rule 3
    if (jjtGetNumChildren() == 1) {
      // TODO: type
      XPathExpr xstep = (XPathExpr) jjtGetChild(0);

      if (!(xstep instanceof XPathAxisStep))
        return Double.MIN_VALUE; // not a pattern, should bark?

      XPathAxisStep step = (XPathAxisStep) xstep;
      XPathNodeTest nt = step.getNodeTest();

      if (!step.hasPredicates()
          && (step.getAxis() == XPathAxisStep.CHILD || step.getAxis() == XPathAxisStep.ATTRIBUTE)) {

        // rule 3:
        if ((nt instanceof XPathNameTest && !(((XPathNameTest) nt).isMultiple))
            || (nt instanceof XPathPITest && ((XPathPITest) nt)._target != null))
          return 0;

        // Mighty Table, 1st row
        if (nt instanceof XPathElementTest) {
          XPathElementTest et = (XPathElementTest) nt;
          if (et.getQName() == null)
            return -0.5;
          if (et.isMultiple()) {
            // Mighty Table, 2nd row
            if (et.getTypeName() == null)
              return -0.5;
            // Mighty Table, 6th row
            return 0;
          }
          // Mighty Table, 5th row
          if (et.getTypeName() == null)
            return 0;
          // Mighty Table, 9th row
          return 0.25;
        }

        if (nt instanceof XPathAttributeTest) {
          XPathAttributeTest at = (XPathAttributeTest) nt;
          // Mighty Table, 3rd row
          if (at.getQName() == null)
            return -0.5;
          if (at.isMultiple()) {
            // Mighty Table, 4th row
            if (at.getTypeName() == null)
              return -0.5;
            // Mighty Table, 8th row
            return 0;
          }
          // Mighty Table, 7th row
          if (at.getTypeName() == null)
            return 0;
          // Mighty Table, 11th row
          return 0.25;
        }

        if (nt instanceof XPathSchemaElementTest) {
          // Mighty Table, 10th row
          return 0.25;
        }

        if (nt instanceof XPathSchemaAttributeTest) {
          // Mighty Table, 10th row
          return 0.25;
        }

        if (nt instanceof XPathDocumentTest) {
          XPathDocumentTest dt = (XPathDocumentTest) nt;
          if (dt.jjtGetNumChildren() == 0)
            return -0.5;
          XPathElementTest et = dt.getElementTest();
          XPathPathExpr sniff = new XPathRelativePathExpr();
          sniff.addStepAtHead(new XPathAxisStep(XPathAxisStep.CHILD, et));
          return sniff.defaultPriority();
        }

        if (nt instanceof XPathNameTest) {
          // can safely assume multiple
          XPathNameTest nnt = (XPathNameTest) nt;
          QName q = nnt.getQName();
          if (!"*".equals(q.getName()))
            return -0.25;
          if (!"*".equals(q.getNamespaceURI()))
            return -0.25;
        }

        return -0.5;
      } // has no predicates
    } // is singleton step
    return 0.5;
  }

  public short getType() {
    if (getStepCount() == 0)
      return TYPE_NODELIST; // / is a node
    try {
      return getLastStep().getType();
    } catch (XSLToolsXPathException ex) {
      throw new AssertionError(
          "This should never happen: Exception thrown because no steps, but we just checked that steps were present");
    }
  }

  @Override
public String toString() {
    StringBuilder res = new StringBuilder();
    boolean needsSlash = false;
    for (int i = 0; i < jjtGetNumChildren(); i++) {
      Node n = jjtGetChild(i);
      String ch = n.toString();
      if (needsSlash /* && !"".equals(ch) */)
        res.append('/');
      else
        needsSlash = true;
      res.append(ch);
    }
    return res.toString();
  }

  public String toFilterExprFreeString() {
    String s = toString();
    int start;
    int end;
    while ((start = s.indexOf('[')) >= 0) {
      end = s.indexOf(']');
      s = s.substring(0, start) + s.substring(end + 1);
    }
    return s;
  }
}
