/* Generated By:JJTree: Do not edit this line. XPathNameOrWildcardTest.java */

package dongfang.xsltools.xpath2;

import java.util.Collections;
import java.util.Set;

import org.dom4j.QName;

import dongfang.xsltools.exceptions.XSLToolsSchemaException;
import dongfang.xsltools.xmlclass.CharGenerator;
import dongfang.xsltools.xmlclass.schemaside.AttributeUse;
import dongfang.xsltools.xmlclass.schemaside.ElementUse;
import dongfang.xsltools.xmlclass.schemaside.SingleTypeXMLClass;
import dongfang.xsltools.xmlclass.xslside.AttributeNT;
import dongfang.xsltools.xmlclass.xslside.CommentNT;
import dongfang.xsltools.xmlclass.xslside.ElementNT;
import dongfang.xsltools.xmlclass.xslside.NodeType;
import dongfang.xsltools.xmlclass.xslside.PINT;
import dongfang.xsltools.xmlclass.xslside.RootNT;
import dongfang.xsltools.xmlclass.xslside.TextNT;
import dongfang.xsltools.xmlclass.xslside.UndeclaredNodeType;

public class XPathNameTest extends XPathQNamedNodeTest {
  public XPathNameTest(int id) {
    super(id);
  }

  public XPathNameTest(XPathParser p, int id) {
    super(p, id);
  }

  public XPathNameTest(QName name) {
    super(name);
  }

  @Override
  public boolean accept(ElementUse nt, SingleTypeXMLClass clazz) {
    if (qname.equals(nt.getQName()))
      return true;

    // Now all em bloody principal node kind tests...
    String testLocal = qname.getName();
    String testURI = qname.getNamespaceURI();

    // case {foo}:bar (no wildcard at all), and we're not {foo}:bar
    if (!(testLocal.equals("*")) && !(testURI.equals("*"))) {
      return false;
    }

    // case {*}:* (complete wildcard)
    if (testLocal.equals("*") && testURI.equals("*")) {
      return true;
    }

    String ntLocal = nt.getQName().getName();
    String ntURI = nt.getQName().getNamespaceURI();

    // case {foo}:*
    if (testLocal.equals("*"))
      return testURI.equals(ntURI);

    // case {*}:bar
    if (testURI.equals("*"))
      return testLocal.equals(ntLocal);

    throw new AssertionError("all cases should have been exhausted!");
  }

  @Override
  public boolean accept(AttributeUse nt, SingleTypeXMLClass clazz) {
    if (qname.equals(nt.getQName()))
      return true;

    // Now all em bloody principal node kind tests...
    String testLocal = qname.getName();
    String testURI = qname.getNamespaceURI();

    // case {foo}:bar (no wildcard at all), and we're not {foo}:bar
    if (!(testLocal.equals("*")) && !(testURI.equals("*"))) {
      return false;
    }

    // case {*}:* (complete wildcard)
    if (testLocal.equals("*") && testURI.equals("*")) {
      return true;
    }

    String ntLocal = nt.getQName().getName();
    String ntURI = nt.getQName().getNamespaceURI();

    // case {foo}:*
    if (testLocal.equals("*"))
      return testURI.equals(ntURI);

    // case {*}:bar
    if (testURI.equals("*"))
      return testLocal.equals(ntLocal);

    throw new AssertionError("all cases should have been exhausted!");
  }

  @Override
  boolean accept(CommentNT nt) {
    return false;
  }

  @Override
  boolean accept(PINT nt) {
    return false;
  }

  @Override
  boolean accept(RootNT nt, SingleTypeXMLClass clazz) {
    return false;
  }

  @Override
  boolean accept(TextNT nt) {
    return false;
  }

  @Override
public Set<UndeclaredNodeType> etest(Set<UndeclaredNodeType> delta) {
    UndeclaredNodeType tester = new ElementNT(qname);
    if (delta.contains(NodeType.ONE_ANY_NAME_ELEMENT_NT))
      return Collections.singleton(tester);
    if (delta.contains(tester))
      return Collections.singleton(tester);
    return Collections.emptySet();
  }

  @Override
public Set<UndeclaredNodeType> atest(Set<UndeclaredNodeType> delta) {
    UndeclaredNodeType tester = new AttributeNT(qname);
    if (delta.contains(NodeType.ONE_ANY_NAME_ATTRIBUTE_NT))
      return Collections.singleton(tester);
    if (delta.contains(tester))
      return Collections.singleton(tester);
    return Collections.emptySet();
  }

  /*
   * public Set<UndeclaredNodeType> etest(Set<UndeclaredNodeType> delta) { if
   * (qname.getName().equals("*") || qname.getNamespaceURI().equals("*")) { Set<UndeclaredNodeType>
   * result = new HashSet<UndeclaredNodeType>(); for (UndeclaredNodeType
   * t:delta) if (t instanceof ElementNT) result.add(t); return result; }
   * UndeclaredNodeType tester = new ElementNT(qname); if
   * (delta.contains(NodeType.ONE_ANY_NAME_ELEMENT_NT)) return
   * Collections.singleton(tester); if (delta.contains(tester)) return
   * Collections.singleton(tester); return Collections.emptySet(); }
   * 
   * public Set<UndeclaredNodeType> atest(Set<UndeclaredNodeType> delta) { if
   * (qname.getName().equals("*") || qname.getNamespaceURI().equals("*")) { Set<UndeclaredNodeType>
   * result = new HashSet<UndeclaredNodeType>(); for (UndeclaredNodeType
   * t:delta) if (t instanceof AttributeNT) result.add(t); return result; }
   * UndeclaredNodeType tester = new AttributeNT(qname); if
   * (delta.contains(NodeType.ONE_ANY_NAME_ATTRIBUTE_NT)) return
   * Collections.singleton(tester); if (delta.contains(tester)) return
   * Collections.singleton(tester); return Collections.emptySet(); }
   */

  @Override
public String toString() {
    return qname.getQualifiedName();
  }

  @Override
  public String testAttributeAxisRegExp(SingleTypeXMLClass clazz)
      throws XSLToolsSchemaException {
    String regexp = "";
    QName name = getQName();
    if (name.getName().equals("*")) {
      regexp += clazz.getAttributeRegExp();
    } else {
      Character C = clazz.getCharForAttributeName(name);
      if (C == null)
        regexp += CharGenerator.getAbsurdChar();
      else
        regexp += C.charValue();
    }
    return "(" + regexp + ")";
  }

  @Override
  public String testSDOSAxisRegExp(SingleTypeXMLClass clazz)
      throws XSLToolsSchemaException {
    return testCDAxisRegExp(clazz);
  }

  @Override
  public String testCDAxisRegExp(SingleTypeXMLClass clazz)
      throws XSLToolsSchemaException {
    QName name = getQName();
    if (name.getName().equals("*"))
      return clazz.getElementRegExp();
    return "" + clazz.getCharForElementName(name);
  }
}