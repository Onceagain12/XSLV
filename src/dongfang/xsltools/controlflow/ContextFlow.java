package dongfang.xsltools.controlflow;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.dom4j.Branch;
import org.dom4j.DocumentFactory;
import org.dom4j.Element;

import dongfang.xsltools.diagnostics.Diagnoseable;
import dongfang.xsltools.xmlclass.xslside.DeclaredNodeType;

/**
 * Describes the flow of context nodes from a (selection, context node) pair. In
 * other words: Describes the flow of context nodes generated by a context node,
 * through a certain selection, to any number of target template rules.
 * 
 * There is one of these for each (selection, context type) pair
 */
class ContextFlow extends HashMap<TemplateRule, Set<DeclaredNodeType>>
    implements Diagnoseable {
  // Set<TemplateRule> possibleTargets = new HashSet<TemplateRule>();
  // TemplateRule objects that are possible targets of
  // (selection, source context) pair.
  // Set<TemplateRule> discardedTargets = new HashSet<TemplateRule>();
  // TemplateRule objects that have been discarded as possible
  // targets of (selection, source context) pair.

  /**
	 * 
	 */
	private static final long serialVersionUID = 2785353832794703280L;
static final ContextFlow EMPTY = new ContextFlow() {
    /**
	 * 
	 */
	private static final long serialVersionUID = -2812430058319569334L;

	@Override
	public Set<DeclaredNodeType> put(TemplateRule r, Set<DeclaredNodeType> s) {
      System.err.println("Someone did a put on empty ContextFlow");
      return null;
    }
  };

  /**
   * Fill up supplied set with union of context flow successors for all targets
   * 
   * @param result
   */
  public void getContextFlowSuccessorsForAllTargets(/*Map<DeclaredNodeType,DeclaredNodeType>*/
      Set<DeclaredNodeType> result) {
    for (Map.Entry<TemplateRule, Set<DeclaredNodeType>> e : entrySet()) {
      Set<? extends DeclaredNodeType> edgeFlow = e.getValue();
      // Merge:
      result.addAll(edgeFlow);
      /*
      for (DeclaredNodeType type : edgeFlow) {
        result.put(type, type);
      }
      */
    }
  }

  public void diagnostics(Branch parent, DocumentFactory fac, Set<Object> configuration) {
    _diagnostics(parent, fac, configuration);
  }

  boolean _diagnostics(Branch parent, DocumentFactory fac, Set<Object> configuration) {
    boolean result = false;
    List<TemplateRule> trs = new ArrayList<TemplateRule>(keySet());
    Collections
        .sort(trs, ControlFlowFunctions.getTemplateDiagnosticsOrdering());

    for (TemplateRule tr : trs) {
      //Element flowDiag = fac.createElement(Util
      //    .capitalizedStringToHyphenString(getClass()));
      // Element target = fac.createElement("template-rule-index");
      // flowDiag.add(target);
      // target.add(fac.createText(Integer.toString(tr.index)));
      
            if (get(tr) == null || get(tr).isEmpty()) {
        // flowDiag.add(fac.createElement("dead-flow"));
      } else {
        Element trx = tr.briefIdDiagnostics(parent, "target-template-rule", fac);
        result = true;
        //parent.add(flowDiag);

        List<DeclaredNodeType> sorted = new ArrayList<DeclaredNodeType>(get(tr));
        Collections.sort(sorted);

        for (DeclaredNodeType nt : sorted) {
          nt.diagnostics(trx, fac, configuration);
        }
      }
    }
    return result;
  }
}
